# 考察メモ

- 解が出る方針ではなく、良い解が出る方針を探す

# 10/14

- 指数分布の推定？
- 大小関係しかわからない

## 比較で得られる情報

- (A+d) - (B+c) > 0
- A - B > 0

- A - B - c + d > 0
    - A - B > c - d

- (A+d) - (B+c) > 0
- A - B < 0

- d - c > B - A

## 入力

- N: rand_int(30, 100)
- D: rand_int(2, floor(N / 4))
    - 2 <= D <= N / 4
- Q: round(N * 2 ^ rand_double(1, 5))
    - 2N <= Q <= 32N
    - 8D <= Q <= 128D

## 考察ポイント

- どれを入れ替えるか、どう判断する？
    - 序盤はなるべく重いもの、終盤は軽いものを入れ替えるのがよさそう？
    - 入れ替えた時に変動があったかどうか、だけが情報となる
    - => 各アイテムの重量の推定値があると嬉しい
- モンテカルロが効きそう？
- 変動が大きくなった時、良い解になっているかどうか、どう判断する？
    - 必ずしもグループに入っているものを検証する必要はない

- 集合の重さははどういう分布に従うか

## 方針

- 初期解作って、いじって大小関係が変わるところを探す
- 一個ずつ試す

## 方針1: 初期解作って、いじって大小関係が変わるところを探す

- ランダムに割り当てて、大小関係が入れ替わるところを探す
- 大きいところから小さいところに移動させるとよさそう
    - 常に集合の大小関係を保持しておく
    - バブルソートの要領でO(D)で更新できそう

```rust
groups: Vec<Vec<usize>>;
rank: Vec<usize>;

fn sort_groups(groups: &Vec<Vec<usize>>) -> Vec<usize>;

fn insert_group(g_idx: usize, from_up: bool);
```

1. ランダムにグループに割り振る
2. ソートして順位をつける（`O(D * log D)`）
3. 一番重いグループから軽いグループに移す
4. 順位を更新する（`O(D)`）
5. 3.に戻る

## n個の大小関係が知りたい時、最低何回の天秤操作でわかる？

- ソートと同じことをやる
- クイックソートを実装できればO(D * log D)
    - 最悪O(D^2)
- Dが大きく、Qが少ないケースだとダメそう

```rust
// デバッグ用
let rank_correct = sort_groups(&groups, input, interactor);
if rank.len() == rank_correct.len() {
    assert_eq!(rank_correct, rank);
}
```

- しばらくすると、更新されなくなる（局所解にはまる）

## 重さを知ると、最適解がわかる

- 焼きなましで（ほぼ）最適解がわかる

- 順位の更新は二分探索できそう
    - Dが大きいケースは効きそうだが、小さいケースは悪化しそう

## 課題と改善方針

1. クエリ数が足りていない
    - 該当するケースは少なそうなので優先度は低いか
2. 局所解にはまっている
3. Dが大きいケースに弱い
