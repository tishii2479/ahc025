# 考察メモ

- 解が出る方針ではなく、良い解が出る方針を探す

# 10/14

- 指数分布の推定？
- 大小関係しかわからない

## 比較で得られる情報

- (A+d) - (B+c) > 0
- A - B > 0

- A - B - c + d > 0
    - A - B > c - d

- (A+d) - (B+c) > 0
- A - B < 0

- d - c > B - A

## 入力

- N: rand_int(30, 100)
- D: rand_int(2, floor(N / 4))
    - 2 <= D <= N / 4
- Q: round(N * 2 ^ rand_double(1, 5))
    - 2N <= Q <= 32N
    - 8D <= Q <= 128D

## 考察ポイント

- どれを入れ替えるか、どう判断する？
    - 序盤はなるべく重いもの、終盤は軽いものを入れ替えるのがよさそう？
    - 入れ替えた時に変動があったかどうか、だけが情報となる
    - => 各アイテムの重量の推定値があると嬉しい
- モンテカルロが効きそう？
- 変動が大きくなった時、良い解になっているかどうか、どう判断する？
    - 必ずしもグループに入っているものを検証する必要はない

- 集合の重さははどういう分布に従うか

## 方針

- 初期解作って、いじって大小関係が変わるところを探す
- 一個ずつ試す

## 方針1: 初期解作って、いじって大小関係が変わるところを探す

- ランダムに割り当てて、大小関係が入れ替わるところを探す
- 大きいところから小さいところに移動させるとよさそう
    - 常に集合の大小関係を保持しておく
    - バブルソートの要領でO(D)で更新できそう

```rust
groups: Vec<Vec<usize>>;
rank: Vec<usize>;

fn sort_groups(groups: &Vec<Vec<usize>>) -> Vec<usize>;

fn insert_group(g_idx: usize, from_up: bool);
```

1. ランダムにグループに割り振る
2. ソートして順位をつける（`O(D * log D)`）
3. 一番重いグループから軽いグループに移す
4. 順位を更新する（`O(D)`）
5. 3.に戻る

## n個の大小関係が知りたい時、最低何回の天秤操作でわかる？

- ソートと同じことをやる
- クイックソートを実装できればO(D * log D)
    - 最悪O(D^2)
- Dが大きく、Qが少ないケースだとダメそう

```rust
// デバッグ用
let rank_correct = sort_groups(&groups, input, interactor);
if rank.len() == rank_correct.len() {
    assert_eq!(rank_correct, rank);
}
```

- しばらくすると、更新されなくなる（局所解にはまる）

## 重さを知ると、最適解がわかる

- 焼きなましで（ほぼ）最適解がわかる

## 考察

- 大きい方と小さい方を近づける
    - グループを2つ選んで大小関係を調べて、
    - その中から大小関係が入れ替わっている集合を選んでswapする
    - グループの大小関係が入れ替わっていなければ改善している
- 都度ソートする必要はない
- 比較結果を保持すれば、同じやつは2回もする必要はない
    - 保持していれば、得ようとしている大小関係もわかるかも
    - 大小関係が単調なペアを通って、経路が存在すれば良い
- 順位がわかれば、重さもなんとなく推定できる
    - 3つのうち、最下位だったらxくらい、とか

## 改善点

- 順位の更新は二分探索できそう
    - Dが大きいケースは効きそうだが、小さいケースは悪化しそう
- 一番大きいところから1個抜いた重さと、一番小さいのを比べて、逆転していたら操作する必要がない

## 課題と改善方針

1. クエリ数が足りていない
    - 該当するケースは少なそうなので優先度は低いか
2. 局所解にはまっている
    - 真ん中の方に入ったら良い？
    - swapが欲しい？
        - 隣のやつとswap？
        - 1:2でswap
        - 最初にswapしようとしているもの同士を比べて、意味があるかどうかを調べる
3. Dが大きいケースに弱い
    - 方針2が効きそう
4. 各荷物の重さをなんとなく推定したい

## 方針2: 2つグループを選択して、近づけるようにswapを繰り返す

- 大きい方と小さい方を近づける
    - グループを2つ選んで大小関係を調べて、
    - その中から大小関係が入れ替わっている集合を選んでswapする
    - グループの大小関係が入れ替わっていなければ改善している
    - swapする個数は何個でも良い

# 10/15

- swapが思ったほど効かない
    - バグ直すと効いた

## 課題

- 終盤は2つ以上swapしたい
    - ギリギリを攻めるには、徐々に錘を追加していく処理が欲しい
- 二分探索した方が良い場面がありそう
    - binary_searchかlinear_searchかうまく判断したい
- 比較結果を保持しておいて活用したい

- 一番大きいのと小さいのが残る可能性がある

- 一番小さいグループが1個だけしか荷物がないパターンがある

- 大きく分けて、以下が必要そう
    - クエリ回数の削減
    - 有効な操作の推論
    - （Qが少ない時の別解法）

- パラメータ調整

## 考察

- グループ内の大小関係を図ると、基準ができるため、クエリ回数を削減することができる

### 改善1: 比較結果の活用

1. 比較した情報の保持
    - ハッシュ化して、すでに存在すればその情報を使用する
2. すでにある比較結果から推論
    - グラフを構築して、辿れるところに行く
3. （すでにある比較結果から、どれくらい重みが離れているか推論）

### 改善2: 2つ以上のswap

1. ランダムに2つ以上swapしてみる
2. 望んだ大小関係になるまで徐々に追加する

### 改善3: 集合の選び方

1. 重い方と軽い方からランダムに選ぶ
2. 端っこから選ばれやすくする
